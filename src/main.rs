use crate::starknet_utils::client::StarknetClient;
use starknet::core::types::{BlockId, BlockTag};
use starknet_utils::client::http::StarknetClientHttp;

mod starknet_utils;

const RPC_URL: &str = &"https://starknet-mainnet.public.blastapi.io";

async fn index_pending_blocks() {
    let client = StarknetClientHttp::new(RPC_URL).unwrap();
    let mut previous_loop_ts = 0;

    loop {
        let (pending_ts, txs) = match client
            .block_txs_hashes(BlockId::Tag(BlockTag::Pending))
            .await
        {
            Ok((ts, txs)) => (ts, txs),
            Err(e) => {
                println!("Error while fetching pending block txs: {:?}", e);
                tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
                continue;
            }
        };

        if previous_loop_ts == 0 {
            previous_loop_ts = pending_ts;
        }

        println!("Pending block {} with {} txs", pending_ts, txs.len());

        // If the timestamp is different from the previous loop,
        // we must first ensure we've fetched and processed all the transactions
        // of the previous pending block, which is now the "Latest".
        if pending_ts != previous_loop_ts {
            println!("ts differ! {} {}", pending_ts, previous_loop_ts);
            // Get the latest block number, generated by the sequencer, which is
            // expected to be the one we just processed.
            let block_number = match client.block_number().await {
                Ok(n) => n,
                Err(e) => {
                    println!("Error while fetching latest block number: {:?}", e);
                    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
                    continue;
                }
            };

            // TODO:  handle on_new_latest_block(block_number) ...

            println!(
                "Pending block {} is now latest block number #{}",
                previous_loop_ts, block_number
            );

            previous_loop_ts = pending_ts;
        }

        tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;
    }
}

fn main() {
    tokio::runtime::Runtime::new()
        .unwrap()
        .block_on(index_pending_blocks());
}
